[
["bayes-rule-and-the-grid-method.html", "5 Bayes’ Rule and the Grid Method 5.1 Estimating the bias in a coin using the Grid Method", " 5 Bayes’ Rule and the Grid Method 5.1 Estimating the bias in a coin using the Grid Method 5.1.1 Creating a Grid library(purrr) x &lt;- 1; n &lt;- 4 CoinsGrid &lt;- expand.grid( theta = seq(0, 1, by = 0.001) ) %&gt;% mutate( prior = pmin(theta, 1 - theta), # higher if farther from edges prior = prior / sum(prior), # normalize likelihood = map_dbl(theta, ~ dbinom(x = x, size = n, .x)), posterior = prior * likelihood, posterior = posterior / sum(posterior) # normalize ) 5.1.2 Plots from the grid gf_line(prior ~ theta, data = CoinsGrid) gf_line(likelihood ~ theta, data = CoinsGrid) gf_line(posterior ~ theta, data = CoinsGrid) gf_area(prior ~ theta, data = CoinsGrid, alpha = 0.5) gf_area(likelihood ~ theta, data = CoinsGrid, alpha = 0.5) gf_area(posterior ~ theta, data = CoinsGrid, alpha = 0.5) 5.1.3 HDI from the grid Let’s write a function to compute the Highest Density Interval (of the posterior for theta) based on our grid. Since different grids may use different names for the parameter(s) and for the posterior, we’ll write our function in a way that will let us specify those names if we need to, but use posterior and theta by default. And for good measure, we’ll calculate the posterior mode as well. The basic idea (after standardizing the grid) is to sort the grid by the posterior. The mode will be at the end of the list, and the “bottom 95%” will be the HDI (or some other percent if we choose a different level). This method works as long as the posterior is unimodal, increasing to the mode from either side. HDI &lt;- function(formula = posterior ~ theta, grid, level = 0.95) { # Create a standardized version of the grid model.frame(formula, data = grid) %&gt;% # turn formula into data frame setNames(c(&quot;posterior&quot;, &quot;theta&quot;)) %&gt;% # standardrize names mutate( posterior = posterior / sum(posterior) # normalize posterior ) %&gt;% arrange(posterior) %&gt;% # sort by posterior mutate( cum_posterior = cumsum(posterior) # cumulative posterior ) %&gt;% filter( cum_posterior &gt;= 1 - level, # keep highest cum_posterior ) %&gt;% summarise( # summarise what&#39;s left lo = min(theta), hi = max(theta), height = min(posterior), level = level, mode_height = last(posterior), mode = last(theta), ) } HDICoins &lt;- HDI(posterior ~ theta, grid = CoinsGrid) HDICoins ## lo hi height level mode_height mode ## 1 0.098 0.681 0.0004832976 0.95 0.002369827 0.4 With this information in hand, we can add a representation of the 95% HDI to our plot. gf_line(posterior ~ theta, data = CoinsGrid) %&gt;% gf_hline(yintercept = ~height, data = HDICoins, color = &quot;red&quot;, alpha = 0.5) %&gt;% gf_pointrangeh(height ~ mode + lo + hi, data = HDICoins, color = &quot;red&quot;, size = 1) %&gt;% gf_labs(caption = &quot;posterior mode and 95% HPI indicated in red&quot;) 5.1.4 Automating the grid BernGrid &lt;- function( x, n, prior = dunif, res = 1001, ...) { Grid &lt;- expand.grid( theta = seq(0, 1, length.out = res) ) %&gt;% mutate( prior = prior(theta, ...), prior = prior / sum(prior), likelihood = dbinom(x, n, theta), likelihood = likelihood / sum(likelihood), posterior = prior * likelihood, posterior = posterior / sum(posterior) ) H &lt;- HDI(grid = Grid) gf_line(prior ~ theta, data = Grid, color = ~&quot;prior&quot;, size = 1.15, alpha = 0.8) %&gt;% gf_line(likelihood ~ theta, data = Grid, color = ~&quot;likelihood&quot;, size = 1.15, alpha = 0.7) %&gt;% gf_line(posterior ~ theta, data = Grid, color = ~&quot;posterior&quot;, size = 1.15, alpha = 0.6) %&gt;% gf_pointrangeh( height ~ mode + lo + hi, data = H, color = &quot;red&quot;, size = 1) %&gt;% gf_labs(title = &quot;Prior/Likelihood/Posterior&quot;, subtitle = paste(&quot;Data: n =&quot;, n, &quot;, x =&quot;, x)) %&gt;% gf_refine( scale_color_manual( values = c( &quot;prior&quot; = &quot;forestgreen&quot;, &quot;likelihood&quot; = &quot;blue&quot;, &quot;posterior&quot; = &quot;red&quot;), breaks = c(&quot;prior&quot;, &quot;likelihood&quot;, &quot;posterior&quot;) )) %&gt;% print() invisible(Grid) # return the Grid, but don&#39;t show it } This function let’s us quickly explore several scenarios and compare the results. How does changing the prior affect the posterior? How does changing the data affect the posterior? library(triangle) BernGrid(1, 4, prior = dtriangle, a = 0, b = 1, c = 0.5) BernGrid(1, 4, prior = dunif) BernGrid(10, 40, prior = dtriangle, a = 0, b = 1, c = 0.5) BernGrid(10, 40, prior = dunif) BernGrid(1, 4, prior = dtriangle, a = 0, b = 1, c = 0.8) BernGrid(10, 40, prior = dtriangle, a = 0, b = 1, c = 0.8) BernGrid(10, 40, prior = dbeta, shape1 = 25, shape2 = 12) "]
]
