[
["simple-linear-regression.html", "17 Simple Linear Regression 17.1 The deluxe basic model 17.2 Example: Galton’s Data 17.3 Centering and Standardizing 17.4 We’ve fit a model, now what? 17.5 Fitting models with Stan 17.6 Multiple Intercepts model 17.7 Exercises", " 17 Simple Linear Regression Situation: Metric response Matric predictor 17.1 The deluxe basic model 17.1.1 Likelihood \\[\\begin{align*} y_{i} &amp;\\sim {\\sf Norm}(\\mu_i, \\sigma) \\\\ \\mu_i &amp;\\sim \\beta_0 + \\beta_1 x_i \\end{align*}\\] Some variations: Replace normal distribution with something else (t is common). Allow standard deviations to vary with \\(x\\) as well as the mean. Use a different functional relationship between explanatory and response (non-linear regression) Each of these is relatively easy to do. The first variation is sometimes called robust regression becuase it is more robust to unusual observations. Since it is no harder to work with t distributions than with normal distributions, that will become our go-to simple linear regression model. \\[\\begin{align*} y_{i} &amp;\\sim {\\sf T}(\\mu_i, \\sigma, \\nu) \\\\ \\mu_i &amp;\\sim \\beta_0 + \\beta_1 x_i \\end{align*}\\] 17.1.2 Priors We need priors for \\(\\beta_0\\), \\(\\beta_1\\), \\(\\sigma\\), and \\(\\nu\\). \\(\\nu\\): We’ve already seend that a shifted Gamma with mean around 30 works well as a generic prior giving the data room to stear us away from normality if warranted. \\(\\beta_1\\): The MLE for \\(\\beta_1\\) is \\[ \\hat\\beta_1 = r \\frac{SD_y}{SD_x}\\] so it makes sense to have a prior broadly covers the interval \\((- \\frac{SD_y}{SD_x}, \\frac{SD_y}{SD_x})\\). \\(\\beta_0\\): The MLE for \\(\\beta_0\\) is \\[ \\hat\\beta_0 \\; = \\; \\overline{y} - \\hat \\beta_1 \\overline{x} \\; = \\; \\overline{y} - r \\frac{SD_y}{SD_x} \\cdot \\overline{x}\\] so we can pick a prior that broadly covers the interval \\((\\overline{y} - \\frac{SD_y}{SD_x} \\cdot \\overline{x}, \\overline{y} - \\frac{SD_y}{SD_x} \\cdot \\overline{x})\\) \\(\\sigma\\) measures the amount of variability in responses for a fixed value of \\(x\\) (and is assumed to be the same for each \\(x\\) in the simple version of the model). A weakly informative prior should cover the range of reasonable values of \\(\\sigma\\) with plenty of room to spare. (Our 2-or-3-orders-of-magnititude-either-way uniform distribution might be a reasonable starting point.) Here’s the big picture: 17.2 Example: Galton’s Data Since we are looking at regression, let’s use an historical data set that was part of the origins of the regression story: Galton’s data on height. Galton collected data on the heights of adults and their parents. head(mosaicData::Galton) family father mother sex height nkids 1 78.5 67.0 M 73.2 4 1 78.5 67.0 F 69.2 4 1 78.5 67.0 F 69.0 4 1 78.5 67.0 F 69.0 4 2 75.5 66.5 M 73.5 4 2 75.5 66.5 M 72.5 4 To keep things simpler for the moment, let’s consider only women, and only one sibling per family. set.seed(54321) library(dplyr) GaltonW &lt;- mosaicData::Galton %&gt;% filter(sex == &quot;F&quot;) %&gt;% group_by(family) %&gt;% sample_n(1) Galton was interested in how people’s heights are related to their parents’ heights. He compbined the parents’ heights into the “mid-parent height”, which was the average of the two. GaltonW &lt;- GaltonW %&gt;% mutate(midparent = (father + mother) / 2) gf_point(height ~ midparent, data = GaltonW, alpha = 0.5) 17.2.1 Describing the model to JAGS galton_model &lt;- function() { for (i in 1:length(y)) { y[i] ~ dt(mu[i], 1/sigma^2, nu) mu[i] &lt;- beta0 + beta1 * x[i] } sigma ~ dunif(6/100, 6 * 100) nuMinusOne ~ dexp(1/29) nu &lt;- nuMinusOne + 1 beta0 ~ dnorm(0, 1/100^2) # 100 is order of magnitude of data beta1 ~ dnorm(0, 1/4^2) # expect roughly 1-1 slope } library(R2jags) library(mosaic) galton_jags &lt;- jags( model = galton_model, data = list(y = GaltonW$height, x = GaltonW$midparent), parameters.to.save = c(&quot;beta0&quot;, &quot;beta1&quot;, &quot;sigma&quot;, &quot;nu&quot;), n.iter = 5000, n.burnin = 2000, n.chains = 4, n.thin = 1 ) ## module glm loaded library(bayesplot) library(CalvinBayes) summary(galton_jags) ## fit using jags ## 4 chains, each with 5000 iterations (first 2000 discarded) ## n.sims = 12000 iterations saved ## mu.vect sd.vect 2.5% 25% 50% 75% 97.5% Rhat n.eff ## beta0 10.695 8.008 -4.072 5.664 11.532 17.189 24.534 4.376 4 ## beta1 0.800 0.120 0.593 0.702 0.787 0.877 1.020 4.071 4 ## nu 33.016 27.311 6.134 14.178 24.807 42.854 106.351 1.002 1600 ## sigma 1.849 0.130 1.594 1.761 1.849 1.935 2.102 1.020 140 ## deviance 699.315 4.276 694.765 696.069 697.727 701.525 709.475 2.312 6 ## ## DIC info (using the rule, pD = var(deviance)/2) ## pD = 3.3 and DIC = 702.6 mcmc_combo(as.mcmc(galton_jags)) 17.2.2 Problems and how to fix them Clearly something is not working the way we would like with this model! Here’s a clue as to the problem: posterior(galton_jags) %&gt;% gf_point(beta0 ~ beta1, color = ~ chain, alpha = 0.2, size = 0.4) %&gt;% gf_density2d(alpha = 0.5) posterior(galton_jags) %&gt;% filter(iter &lt;= 250, chain == &quot;chain:1&quot;) %&gt;% gf_step(beta0 ~ beta1, alpha = 0.8, color = ~iter) %&gt;% gf_density2d(alpha = 0.2) %&gt;% gf_refine(scale_color_viridis_c()) %&gt;% gf_facet_wrap(~chain) #, scales = &quot;free&quot;) The correlation of the parameters in the posterior distribution produces a long, narrow, diagonal ridge that the Gibbs sampler samples only very slowly because it keeps bumping into edge of the cliff. (Remember, the Gibbs sampler only moves in “primary” directions.) So how do we fix this? This is supposed to be the simple linear model after all. There are two ways we could hope to fix our problem. Reparameterize the model so that the correlation between parameters (in the posterior distribution) is reduced or eliminated. Use a different algorithm for posterior sampling. The problem is not with our model per se, rather it is with the method we are using (Gibbs) to sample from the posterior. Perhaps another algorithm will work better. 17.3 Centering and Standardizing Reparameterization 1: centering We can express this model as \\[\\begin{align*} y_{i} &amp;\\sim {\\sf T}(\\mu_i, \\sigma, \\nu) \\\\ \\mu_i &amp;= \\alpha_0 + \\alpha_1 (x_i - \\overline{x}) \\end{align*}\\] Since \\[\\begin{align*} \\alpha_0 + \\alpha_1 (x_i - \\overline{x}) &amp;= (\\alpha_0 - \\alpha_1 \\overline{x}) + \\alpha_1 x_i \\end{align*}\\] We see that \\(\\beta_0 = \\alpha_0 - \\alpha_1 \\overline{x}\\) and \\(\\beta_1 = \\alpha_1\\). So we can easily recover the original parameters if we like. (And if we are primarily interested in \\(\\beta_1\\), no translation is required.) This reparameterization maintains the natural scale of the data, and both \\(\\alpha_0\\) and \\(\\alpha_1\\) are easily interpreted: \\(\\alpha_0\\) is the mean response when the predictor is the average of the predictor values in the data. Reparameterization 2: standardization We can also express our model as \\[\\begin{align*} z_{y_{i}} &amp;\\sim {\\sf T}(\\mu_i, \\sigma, \\nu) \\\\[3mm] \\mu_i &amp;= \\alpha_0 + \\alpha_1 z_{x_i} \\\\[5mm] z_{x_i} &amp;= \\frac{x_i - \\overline{x}}{SD_x} \\\\[3mm] z_{y_i} &amp;= \\frac{y_i - \\overline{y}}{SD_y} \\\\[3mm] \\end{align*}\\] Here the change in the model is due to a transformation of the data. Subtracting the mean and dividing by the standard deviation is called standardization, and the values produced are sometimes called z-scores. The resulting distributions of \\(zy\\) and \\(zx\\) will have mean 0 and standard deviation 1. So in addition to breaking the correlation pattern, we have now put things on a standard scale, regardless of what the original units were. This can be useful for picking constants in priors (we won’t have to estimate the scale of the data involved). In addition, some algorithms work better if all the variables involved have roughly the same scale. The downside is that we usually need to convert back to the original scales of \\(x\\) and \\(y\\) in order to interpret the results. But this is only a matter of a little easy algebra: \\[\\begin{align*} \\hat{z}_{y_i} &amp;= \\alpha_0 + \\alpha_1 z{x_i} \\\\ \\frac{\\hat{y}_i - \\overline{y}}{SD_y} &amp;= \\alpha_0 + \\alpha_1 \\frac{x_i - \\overline{x}}{SD_x} \\\\ \\hat{y}_i &amp;= \\overline{y} + \\alpha_0 SD_y + \\alpha_1 SD_y \\frac{x_i - \\overline{x}}{SD_x} \\\\ \\hat{y}_i &amp;= \\underbrace{\\left[\\overline{y} + \\alpha_0 SD_y - \\alpha_1\\frac{SD_y}{SD_x} \\overline{x} \\right]}_{\\beta_0} + \\underbrace{\\left[\\alpha_1 \\frac{SD_y}{SD_x}\\right]}_{\\beta_1} x_i \\end{align*}\\] Since Kruscske demonstrates standardization, we’ll do centering here. galtonC_model &lt;- function() { for (i in 1:length(y)) { y[i] ~ dt(mu[i], 1/sigma^2, nu) mu[i] &lt;- alpha0 + alpha1 * (x[i] - mean(x)) } sigma ~ dunif(6/100, 6 * 100) nuMinusOne ~ dexp(1/29) nu &lt;- nuMinusOne + 1 alpha0 ~ dnorm(0, 1/100^2) # 100 is order of magnitude of data alpha1 ~ dnorm(0, 1/4^2) # expect roughly 1-1 slope beta0 = alpha0 - alpha1 * mean(x) beta1 = alpha1 # not necessary, but gives us both names } galtonC_jags &lt;- jags( model = galtonC_model, data = list(y = GaltonW$height, x = GaltonW$midparent), parameters.to.save = c(&quot;beta0&quot;, &quot;beta1&quot;, &quot;alpha0&quot;, &quot;alpha1&quot;, &quot;sigma&quot;, &quot;nu&quot;), n.iter = 5000, n.burnin = 2000, n.chains = 4, n.thin = 1 ) summary(galtonC_jags) ## fit using jags ## 4 chains, each with 5000 iterations (first 2000 discarded) ## n.sims = 12000 iterations saved ## mu.vect sd.vect 2.5% 25% 50% 75% 97.5% Rhat n.eff ## alpha0 64.105 0.149 63.812 64.004 64.106 64.208 64.390 1.001 12000 ## alpha1 0.740 0.081 0.577 0.687 0.740 0.795 0.900 1.001 12000 ## beta0 14.686 5.428 4.008 11.050 14.655 18.253 25.540 1.001 12000 ## beta1 0.740 0.081 0.577 0.687 0.740 0.795 0.900 1.001 12000 ## nu 32.250 24.769 6.281 14.368 24.592 42.701 98.596 1.001 8600 ## sigma 1.841 0.128 1.585 1.757 1.842 1.926 2.091 1.001 5300 ## deviance 697.587 2.496 694.651 695.740 696.961 698.787 704.017 1.001 12000 ## ## DIC info (using the rule, pD = var(deviance)/2) ## pD = 3.1 and DIC = 700.7 mcmc_combo(as.mcmc(galtonC_jags)) Ah! That looks much better than before. 17.3.1 \\(\\beta_0\\) and \\(\\beta_1\\) are still correlated Reparameterization has not changed our model, only the way it is described. In particular, \\(\\beta_0\\) and \\(\\beta_1\\) remain correlated in the posterior. But \\(\\alpha_0\\) and \\(\\alpha_1\\) are not correlated, and these are the parameters JAGS is using to sample. gf_point(beta1 ~ beta0, data = posterior(galtonC_jags), alpha = 0.1) gf_point(alpha1 ~ alpha0, data = posterior(galtonC_jags), alpha = 0.1) 17.4 We’ve fit a model, now what? After centering or standardizing, JAGS works much better. We can now sample from our posterior distribution. But what do we do with our posterior samples? 17.4.1 Estimate parameters If we are primarily interested in a regression parameter (usually the slope parameter is much more interesting than the intercept parameter), we can use an HDI to express our estimate. hdi(posterior(galtonC_jags), pars = &quot;beta1&quot;) par lo hi prob beta1 0.5825 0.9044 0.95 mcmc_areas(as.mcmc(galtonC_jags), pars = &quot;beta1&quot;, prob = 0.95) Galton noticed what we see here: that the slope is less than 1. This means that children of taller than average parents tend to be shorter than their parents and children of below average parents tend to be taller than their parents. He referred to this in his paper as “regression towards mediocrity”. As it turns out, this was not a special feature of the heridity of heights but a general feature of linear models. Find out more in this Wikipedia artilce. 17.4.2 Make predictions Suppse we know the heights of a father and mother, from which we compute ther mid-parent height \\(x\\). How tall would we predict their daughters will be as adults? Each posterior sample provides an answer by describing a t distribution with nu degrees of freedom, mean \\(\\beta_0 + \\beta_1 x\\), and standard deviation \\(\\sigma\\). The posterior distribution of the average hieght of daughters born to parents with midparent height \\(x = 70\\) is shown below, along with an HDI. posterior(galtonC_jags) %&gt;% mutate(mean_daughter = beta0 + beta1 * 70) %&gt;% gf_dens(~mean_daughter) Galton_hdi &lt;- posterior(galtonC_jags) %&gt;% mutate(mean_daughter = beta0 + beta1 * 70) %&gt;% hdi(pars = &quot;mean_daughter&quot;) Galton_hdi par lo hi prob mean_daughter 65.89 67.07 0.95 So on average, we would predict the daughters to be about 66 or 67 inches tall. We can visualize this by drawing a line for each posterior sample. The HDI should span the middle 95% of these. gf_abline(intercept = ~beta0, slope = ~beta1, alpha = 0.01, color = &quot;steelblue&quot;, data = posterior(galtonC_jags) %&gt;% sample_n(2000)) %&gt;% gf_point(height ~ midparent, data = GaltonW, inherit = FALSE, alpha = 0.5) %&gt;% gf_errorbar(lo + hi ~ 70, data = Galton_hdi, color = &quot;skyblue&quot;, width = 0.2, size = 1.2, inherit = FALSE) But this may not be the sort of prediction we want. Notice that most daughters’ heights are not in the blue band in the picture. That band tells about the mean but doesn’t take into account how much individuals vary about that mean. We can add that information in by taking our estimate for \\(\\sigma\\) into account. Here we generate heights by adding noise to the estimate given by values of \\(\\beta_0\\) and \\(\\beta_1\\). posterior(galtonC_jags) %&gt;% mutate(new_ht = beta0 + beta1 * 70 + rstudent_t(1200, df = nu, sd = sigma)) %&gt;% gf_point(new_ht ~ 70, alpha = 0.01, size = 0.7, color = &quot;steelblue&quot;) %&gt;% gf_point(height ~ midparent, data = GaltonW, inherit = FALSE, alpha = 0.5) Galton_hdi2 &lt;- posterior(galtonC_jags) %&gt;% mutate(new_ht = beta0 + beta1 * 70 + rstudent_t(1200, df = nu, sd = sigma)) %&gt;% hdi(regex_pars = &quot;new&quot;) Galton_hdi2 par lo hi prob new_ht 62.61 70.35 0.95 So our model expects that most daughters whose parents have a midparent height of 70 inches are between 62.6 and 70.3 inches tall. Notice that this interval is taking into account both the uncertainty in our estimates of the parameters \\(\\beta_0\\), \\(\\beta_1\\), \\(\\sigma\\), and \\(\\nu\\) and the variability in heights that \\(\\sigma\\) and \\(\\nu\\) indicate. 17.4.3 Posterior Predictive Checks With a little more work, we can create intervals like this at several different midparent heights. Post_galtonC &lt;- posterior(galtonC_jags) Grid &lt;- expand.grid(midparent = 60:75, iter = 1:nrow(Post_galtonC)) posterior(galtonC_jags) %&gt;% mutate(noise = rstudent_t(12000, df = nu, sd = sigma)) %&gt;% left_join(Grid) %&gt;% mutate(height = beta0 + beta1 * midparent + noise) %&gt;% group_by(midparent) %&gt;% do(hdi(., pars = &quot;height&quot;)) ## Joining, by = &quot;iter&quot; ## # A tibble: 16 x 5 ## # Groups: midparent [16] ## midparent par lo hi prob ## &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 60 height 55.3 63.0 0.95 ## 2 61 height 56.1 63.7 0.95 ## 3 62 height 56.8 64.3 0.95 ## 4 63 height 57.6 65.0 0.95 ## 5 64 height 58.3 65.7 0.95 ## 6 65 height 59.1 66.5 0.95 ## 7 66 height 59.9 67.2 0.95 ## 8 67 height 60.6 67.9 0.95 ## 9 68 height 61.4 68.7 0.95 ## 10 69 height 62.2 69.6 0.95 ## 11 70 height 62.9 70.3 0.95 ## 12 71 height 63.7 71.1 0.95 ## 13 72 height 64.2 71.7 0.95 ## 14 73 height 65.0 72.5 0.95 ## 15 74 height 65.6 73.2 0.95 ## 16 75 height 66.4 74.1 0.95 posterior(galtonC_jags) %&gt;% mutate(noise = rstudent_t(12000, df = nu, sd = sigma)) %&gt;% left_join(Grid) %&gt;% mutate(avg_height = beta0 + beta1 * midparent, height = avg_height + noise) %&gt;% group_by(midparent) %&gt;% do(hdi(., pars = &quot;height&quot;)) %&gt;% gf_ribbon(lo + hi ~ midparent, fill = &quot;steelblue&quot;, alpha = 0.2) %&gt;% gf_errorbar(lo + hi ~ midparent, width = 0.2, color = &quot;steelblue&quot;, size = 1.2) %&gt;% gf_point(height ~ midparent, data = GaltonW, inherit = FALSE, alpha = 0.5) ## Joining, by = &quot;iter&quot; Comparing the data to the posterior predictions of the model is called a posterior predictive check; we are checking to see whether the data are consistent with what our posterior distribution would predict. In this case, things look good: most, but not all of the data is falling inside the band where our models predicts 95% of new observations would fall. If the posterior predictive check indicates systematic problems with our model, it may lead us to propose another (we hope better) model. 17.4.4 Posterior predictive checks with bayesplot It takes a bit of work to construct the data needed for the plot above. The bayesplot package provides a number of posterior predicitive check (ppc) plots. These functions require two important inputs: y: a vector of response values – usually the values from the original data set. yrep: a matrix of simulated y values. Each row corresponds to one posterior sample. There is one column for each value of y. So the rows of yrep can be compared with y to see if the model is behaving well. Side note: We can compute our simulated \\(y\\) values using predictor values that are just like in our data or using other predictor values of our choosing. The second options lets on consider counterfactual situations. To distinguish these, some people use \\(y_rep\\) for the former and \\(\\tilde{y}\\) for the latter. Now all the work is in creating the yrep matrix. To simplify that, we will use CalvinBayes::posterior_calc(). We will do this two ways, once for average values of height and once for individual values of height (taking into account the variability from person to person as quantified by \\(\\nu\\), and \\(\\sigma\\). y_avg &lt;- posterior_calc( galtonC_jags, height ~ beta0 + beta1 * midparent, data = GaltonW) y_ind &lt;- posterior_calc( galtonC_jags, height ~ beta0 + beta1 * midparent + rstudent_t(nrow(GaltonW), df = nu, sd = sigma), data = GaltonW) The various posterior predictive check plots begin ppc_. Here is an example: ppc_intervals(GaltonW$height, y_avg, x = GaltonW$midparent) ppc_intervals(GaltonW$height, y_ind, x = GaltonW$midparent) If we want a ribbon, like in our plot above, we can almost get it, but ppc_ribbon() connects the dots in a way that isn’t useful for this model. ppc_ribbon(GaltonW$height, y_ind, x = GaltonW$midparent) Fortunately, we can request the data used to create the plot and make our own plot however we like. plot_data &lt;- ppc_ribbon_data(GaltonW$height, y_ind, x = GaltonW$midparent) glimpse(plot_data) ## Observations: 168 ## Variables: 10 ## $ y_id &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22… ## $ y_obs &lt;dbl&gt; 69.0, 65.5, 65.0, 61.0, 64.5, 63.0, 66.5, 65.5, 64.0, 64.5, 68.0, 63.5, 67.5,… ## $ x &lt;dbl&gt; 72.75, 69.75, 67.50, 67.75, 68.00, 67.75, 67.75, 67.50, 67.00, 67.00, 68.00, … ## $ outer_width &lt;dbl&gt; 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.… ## $ inner_width &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.… ## $ ll &lt;dbl&gt; 65.43, 63.27, 61.70, 61.72, 61.96, 61.74, 61.87, 61.66, 61.25, 61.20, 62.00, … ## $ l &lt;dbl&gt; 67.29, 65.09, 63.47, 63.59, 63.79, 63.59, 63.64, 63.45, 63.07, 63.04, 63.82, … ## $ m &lt;dbl&gt; 68.51, 66.32, 64.64, 64.79, 65.01, 64.79, 64.84, 64.63, 64.27, 64.26, 65.03, … ## $ h &lt;dbl&gt; 69.76, 67.54, 65.85, 66.00, 66.17, 66.01, 66.00, 65.82, 65.48, 65.48, 66.21, … ## $ hh &lt;dbl&gt; 71.64, 69.34, 67.68, 67.83, 68.02, 67.87, 67.87, 67.60, 67.28, 67.28, 68.02, … plot_data %&gt;% gf_ribbon(ll + hh ~ x, fill = &quot;steelblue&quot;) %&gt;% gf_ribbon(l + h ~ x, fill = &quot;steelblue&quot;) %&gt;% gf_line(m ~ x, color = &quot;steelblue&quot;) %&gt;% gf_point(y_obs ~ x, alpha = 0.5) plot_data %&gt;% gf_smooth(ll ~ x, color = &quot;steelblue&quot;) %&gt;% gf_smooth(hh ~ x, color= &quot;steelblue&quot;) %&gt;% gf_smooth(m ~ x, color= &quot;steelblue&quot;) %&gt;% gf_point(y_obs ~ x, alpha = 0.5) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; There are quite a number of these, but most only work for certain types of models. apropos(&quot;^ppc_&quot;) ## [1] &quot;ppc_bars&quot; &quot;ppc_bars_grouped&quot; &quot;ppc_boxplot&quot; ## [4] &quot;ppc_data&quot; &quot;ppc_dens&quot; &quot;ppc_dens_overlay&quot; ## [7] &quot;ppc_ecdf_overlay&quot; &quot;ppc_error_binned&quot; &quot;ppc_error_hist&quot; ## [10] &quot;ppc_error_hist_grouped&quot; &quot;ppc_error_scatter&quot; &quot;ppc_error_scatter_avg&quot; ## [13] &quot;ppc_error_scatter_avg_vs_x&quot; &quot;ppc_freqpoly&quot; &quot;ppc_freqpoly_grouped&quot; ## [16] &quot;ppc_hist&quot; &quot;ppc_intervals&quot; &quot;ppc_intervals_data&quot; ## [19] &quot;ppc_intervals_grouped&quot; &quot;ppc_loo_intervals&quot; &quot;ppc_loo_pit&quot; ## [22] &quot;ppc_loo_pit_overlay&quot; &quot;ppc_loo_pit_qq&quot; &quot;ppc_loo_ribbon&quot; ## [25] &quot;ppc_ribbon&quot; &quot;ppc_ribbon_data&quot; &quot;ppc_ribbon_grouped&quot; ## [28] &quot;ppc_rootogram&quot; &quot;ppc_scatter&quot; &quot;ppc_scatter_avg&quot; ## [31] &quot;ppc_scatter_avg_grouped&quot; &quot;ppc_stat&quot; &quot;ppc_stat_2d&quot; ## [34] &quot;ppc_stat_freqpoly_grouped&quot; &quot;ppc_stat_grouped&quot; &quot;ppc_violin_grouped&quot; 17.5 Fitting models with Stan Centering (or standardizing) is sufficient to make JAGS efficient enough to use. But we can also use Stan, and since Stan is not bothered by correlation in the posterior the way JAGS is, Stan works well even without reparamterizing the model. Here is the Stan equivalent to our original JAGS model. data { int&lt;lower=0&gt; N; // N is a non-negative integer vector[N] y; // y is a length-N vector of reals vector[N] x; // x is a length-N vector of reals } parameters { real beta0; real beta1; real&lt;lower=0&gt; sigma; real&lt;lower=0&gt; nuMinusOne; } transformed parameters{ real&lt;lower=0&gt; nu; nu = nuMinusOne + 1; } model { // we could use a for loop like this: // for (i in 1:N) { // y[i] ~ student_t(nu, beta0 + beta1 * x[i], sigma); //} // but vectorization makes things terser: y ~ student_t(nu, beta0 + beta1 * x, sigma); beta0 ~ normal(0, 100); beta1 ~ normal(0, 4); sigma ~ uniform(6.0 / 100.0, 6.0 * 100.0); nuMinusOne ~ exponential(1/29.0); } library(rstan) galton_stanfit &lt;- sampling( galton_stan, data = list( N = nrow(GaltonW), x = GaltonW$midparent, y = GaltonW$height ), chains = 4, iter = 2000, warmup = 1000 ) Note that the slope and intercept parameters remain correlated in the posterior, but this doesn’t bother Stan the way it bothers JAGS. galton_stanfit ## Inference for Stan model: 210145742d5cefe996c77a84ec632eb5. ## 4 chains, each with iter=2000; warmup=1000; thin=1; ## post-warmup draws per chain=1000, total post-warmup draws=4000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## beta0 14.69 0.15 5.47 3.39 11.08 14.81 18.53 25.02 1373 1 ## beta1 0.74 0.00 0.08 0.59 0.68 0.74 0.79 0.91 1372 1 ## sigma 1.84 0.00 0.13 1.59 1.75 1.84 1.92 2.10 1520 1 ## nuMinusOne 31.68 0.63 26.05 5.31 13.08 23.86 42.31 100.70 1711 1 ## nu 32.68 0.63 26.05 6.31 14.08 24.86 43.31 101.70 1711 1 ## lp__ -249.99 0.04 1.35 -253.50 -250.62 -249.66 -249.00 -248.33 1401 1 ## ## Samples were drawn using NUTS(diag_e) at Fri Mar 29 13:31:50 2019. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). gf_point(beta1 ~ beta0, data = posterior(galton_stanfit), alpha = 0.5) mcmc_combo(as.mcmc.list(galton_stanfit), pars = c(&quot;beta0&quot;, &quot;beta1&quot;, &quot;sigma&quot;, &quot;nu&quot;)) 17.6 Multiple Intercepts model In the example above we have been dealing with the women alone, but we can build a model that handles men and women at the same time. One such model is the “mutliple intercpets” model. In this model, both groups (men and women) will have the same slope, but the intercepts are allowed to differ. data { int&lt;lower=0&gt; N; // N is a non-negative integer vector[N] y; // y is a length-N vector of reals vector[N] x; // x is a length-N vector of reals int&lt;lower=1&gt; g[N]; // g is a length-N vector of integers (for groups) } parameters { real beta0; real beta1; real beta2; real&lt;lower=0&gt; sigma; real&lt;lower=0&gt; nuMinusOne; } transformed parameters{ real&lt;lower=0&gt; nu; nu = nuMinusOne + 1; } model { for (i in 1:N) { y[i] ~ student_t(nu, beta0 + beta1 * x[i] + beta2 * g[i], sigma); } beta0 ~ normal(0, 100); beta1 ~ normal(0, 4); beta2 ~ normal(0, 4); sigma ~ uniform(6.0 / 100.0, 6.0 * 100.0); nuMinusOne ~ exponential(1/29.0); } library(rstan) GaltonBoth &lt;- Galton %&gt;% mutate(midparent = (father + mother)/2) %&gt;% group_by(family) %&gt;% sample_n(1) galton2_stanfit &lt;- sampling( galton2_stan, data = list( N = nrow(GaltonBoth), x = GaltonBoth$midparent, y = GaltonBoth$height, g = as.numeric(factor(GaltonBoth$sex)) ), chains = 4, iter = 2000, warmup = 1000 ) galton2_stanfit ## Inference for Stan model: b4742c19665a946915672774ba048aec. ## 4 chains, each with iter=2000; warmup=1000; thin=1; ## post-warmup draws per chain=1000, total post-warmup draws=4000. ## ## mean se_mean sd 2.5% 25% 50% 75% 97.5% n_eff Rhat ## beta0 17.94 0.14 5.02 8.08 14.53 18.02 21.27 27.63 1200 1.01 ## beta1 0.61 0.00 0.08 0.47 0.56 0.61 0.67 0.76 1242 1.01 ## beta2 5.24 0.01 0.28 4.67 5.06 5.24 5.43 5.79 2387 1.00 ## sigma 1.90 0.00 0.12 1.66 1.82 1.90 1.98 2.15 2131 1.00 ## nuMinusOne 30.81 0.59 26.68 5.67 13.38 22.84 39.07 102.15 2074 1.00 ## nu 31.81 0.59 26.68 6.67 14.38 23.84 40.07 103.15 2074 1.00 ## lp__ -300.79 0.04 1.57 -304.60 -301.57 -300.45 -299.67 -298.75 1736 1.00 ## ## Samples were drawn using NUTS(diag_e) at Fri Mar 29 09:19:12 2019. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). galton2_mcmc &lt;- as.mcmc.list(galton2_stanfit) Post_galton2 &lt;- posterior(galton2_stanfit) mcmc_combo(galton2_mcmc, regex_pars = c(&quot;beta&quot;, &quot;sigma&quot;, &quot;nu&quot;)) mcmc_areas(galton2_mcmc, regex_pars = &quot;beta2&quot;) mcmc_pairs(galton2_mcmc, regex_pars = &quot;beta&quot;, off_diag_fun = &quot;hex&quot;) plot_post(Post_galton2$beta2, xlab = &quot;beta2&quot;, hdi_prob = 0.95) ## $posterior ## ESS mean median mode ## var1 2353 5.242 5.239 5.213 ## ## $hdi ## prob lo hi ## 1 0.95 4.733 5.833 GaltonBoth &lt;- GaltonBoth %&gt;% mutate(g = as.numeric(sex)) head(GaltonBoth, 3) ## # A tibble: 3 x 8 ## # Groups: family [3] ## family father mother sex height nkids midparent g ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 78.5 67 M 73.2 4 72.8 2 ## 2 10 74 65.5 F 65.5 1 69.8 1 ## 3 100 69 66 M 71 3 67.5 2 yind &lt;- posterior_calc( galton2_stanfit, yind ~ beta0 + beta1 * midparent + beta2 * g + rstudent_t(nrow(GaltonBoth), df = nu, mean = 0, sd = sigma), data = GaltonBoth ) ppc_intervals_grouped( GaltonBoth$height, yind, group = GaltonBoth$sex, x = GaltonBoth$midparent) ppc_data &lt;- ppc_intervals_data( GaltonBoth$height, yind, group = GaltonBoth$sex, x = GaltonBoth$midparent) glimpse(ppc_data) ## Observations: 197 ## Variables: 11 ## $ y_id &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22… ## $ y_obs &lt;dbl&gt; 73.2, 65.5, 71.0, 75.0, 68.0, 61.0, 67.5, 63.0, 71.0, 69.0, 65.0, 64.5, 74.0,… ## $ group &lt;fct&gt; M, F, M, M, M, F, M, F, M, M, F, F, M, F, M, M, M, F, F, F, M, F, F, F, F, M,… ## $ x &lt;dbl&gt; 72.75, 69.75, 67.50, 67.85, 67.50, 67.75, 68.00, 67.75, 67.75, 67.50, 67.00, … ## $ outer_width &lt;dbl&gt; 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.… ## $ inner_width &lt;dbl&gt; 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.… ## $ ll &lt;dbl&gt; 69.89, 62.87, 66.77, 66.91, 66.74, 61.59, 66.94, 61.67, 66.95, 66.65, 61.35, … ## $ l &lt;dbl&gt; 71.78, 64.78, 68.60, 68.82, 68.68, 63.52, 68.89, 63.52, 68.72, 68.57, 63.14, … ## $ m &lt;dbl&gt; 73.04, 65.98, 69.84, 69.99, 69.91, 64.82, 70.21, 64.80, 70.05, 69.85, 64.35, … ## $ h &lt;dbl&gt; 74.37, 67.25, 71.11, 71.26, 71.10, 66.08, 71.50, 66.10, 71.27, 71.12, 65.60, … ## $ hh &lt;dbl&gt; 76.23, 69.05, 73.00, 73.25, 72.96, 67.94, 73.38, 68.14, 73.13, 73.07, 67.40, … gf_ribbon(ll + hh ~ x, fill = ~ group, data = ppc_data) %&gt;% gf_ribbon(l + h ~ x, fill = ~ group, data = ppc_data) %&gt;% gf_point(y_obs ~ x, color = ~ group, data = ppc_data) %&gt;% gf_facet_grid(group ~ .) We could let other things differ accross groups as well: slopes, sigmas, nu, etc. All of this is easily doable in JAGS or Stan, but for some of these, it is best to use a prior with correlation among certain pairs of parameters. 17.7 Exercises Use Galton’s data on the men to estimate The average of height of men whose parents are 65 and 72 inches tall. The middle 50% of heights of men whose parents are 65 and 72 inches tall. You may use either JAGS or Stan. When centering, why did we center x but not y? "]
]
