[
["nominal-predictors.html", "19 Nominal Predictors 19.1 Example: Fruitflies", " 19 Nominal Predictors 19.1 Example: Fruitflies library(brms) ## Loading required package: Rcpp ## Loading &#39;brms&#39; package (version 2.7.0). Useful instructions ## can be found by typing help(&#39;brms&#39;). A more detailed introduction ## to the package is available through vignette(&#39;brms_overview&#39;). ## Run theme_set(theme_default()) to use the default bayesplot theme. ## ## Attaching package: &#39;brms&#39; ## The following object is masked from &#39;package:mosaic&#39;: ## ## mm ## The following objects are masked from &#39;package:CalvinBayes&#39;: ## ## rhat, rstudent_t library(CalvinBayes) A study of fruitflies (Hanley &amp; Shapiro, 1994) considered whether the female companions (none, 1 pregnant, 8 pregnant, 1 virgin, or 8 virgin) is associated with differenes in longevity of males. gf_violin(Longevity ~ CompanionNumber, data = FruitflyReduced) %&gt;% gf_jitter(width = 0.2, height = 0, alpha = 0.5) It is easy enough to ask brm() to fit this model for us. flies_brm &lt;- brm(Longevity ~ CompanionNumber, data = FruitflyReduced) ## Compiling the C++ model ## Start sampling ## ## SAMPLING FOR MODEL &#39;d906ce8b7473e128d4f1de38161b730f&#39; NOW (CHAIN 1). ## Chain 1: ## Chain 1: Gradient evaluation took 4.8e-05 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.48 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1: ## Chain 1: ## Chain 1: Iteration: 1 / 2000 [ 0%] (Warmup) ## Chain 1: Iteration: 200 / 2000 [ 10%] (Warmup) ## Chain 1: Iteration: 400 / 2000 [ 20%] (Warmup) ## Chain 1: Iteration: 600 / 2000 [ 30%] (Warmup) ## Chain 1: Iteration: 800 / 2000 [ 40%] (Warmup) ## Chain 1: Iteration: 1000 / 2000 [ 50%] (Warmup) ## Chain 1: Iteration: 1001 / 2000 [ 50%] (Sampling) ## Chain 1: Iteration: 1200 / 2000 [ 60%] (Sampling) ## Chain 1: Iteration: 1400 / 2000 [ 70%] (Sampling) ## Chain 1: Iteration: 1600 / 2000 [ 80%] (Sampling) ## Chain 1: Iteration: 1800 / 2000 [ 90%] (Sampling) ## Chain 1: Iteration: 2000 / 2000 [100%] (Sampling) ## Chain 1: ## Chain 1: Elapsed Time: 0.2897 seconds (Warm-up) ## Chain 1: 0.088069 seconds (Sampling) ## Chain 1: 0.377769 seconds (Total) ## Chain 1: ## ## SAMPLING FOR MODEL &#39;d906ce8b7473e128d4f1de38161b730f&#39; NOW (CHAIN 2). ## Chain 2: ## Chain 2: Gradient evaluation took 1.6e-05 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.16 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2: ## Chain 2: ## Chain 2: Iteration: 1 / 2000 [ 0%] (Warmup) ## Chain 2: Iteration: 200 / 2000 [ 10%] (Warmup) ## Chain 2: Iteration: 400 / 2000 [ 20%] (Warmup) ## Chain 2: Iteration: 600 / 2000 [ 30%] (Warmup) ## Chain 2: Iteration: 800 / 2000 [ 40%] (Warmup) ## Chain 2: Iteration: 1000 / 2000 [ 50%] (Warmup) ## Chain 2: Iteration: 1001 / 2000 [ 50%] (Sampling) ## Chain 2: Iteration: 1200 / 2000 [ 60%] (Sampling) ## Chain 2: Iteration: 1400 / 2000 [ 70%] (Sampling) ## Chain 2: Iteration: 1600 / 2000 [ 80%] (Sampling) ## Chain 2: Iteration: 1800 / 2000 [ 90%] (Sampling) ## Chain 2: Iteration: 2000 / 2000 [100%] (Sampling) ## Chain 2: ## Chain 2: Elapsed Time: 0.262878 seconds (Warm-up) ## Chain 2: 0.085439 seconds (Sampling) ## Chain 2: 0.348317 seconds (Total) ## Chain 2: ## ## SAMPLING FOR MODEL &#39;d906ce8b7473e128d4f1de38161b730f&#39; NOW (CHAIN 3). ## Chain 3: ## Chain 3: Gradient evaluation took 1.7e-05 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.17 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3: ## Chain 3: ## Chain 3: Iteration: 1 / 2000 [ 0%] (Warmup) ## Chain 3: Iteration: 200 / 2000 [ 10%] (Warmup) ## Chain 3: Iteration: 400 / 2000 [ 20%] (Warmup) ## Chain 3: Iteration: 600 / 2000 [ 30%] (Warmup) ## Chain 3: Iteration: 800 / 2000 [ 40%] (Warmup) ## Chain 3: Iteration: 1000 / 2000 [ 50%] (Warmup) ## Chain 3: Iteration: 1001 / 2000 [ 50%] (Sampling) ## Chain 3: Iteration: 1200 / 2000 [ 60%] (Sampling) ## Chain 3: Iteration: 1400 / 2000 [ 70%] (Sampling) ## Chain 3: Iteration: 1600 / 2000 [ 80%] (Sampling) ## Chain 3: Iteration: 1800 / 2000 [ 90%] (Sampling) ## Chain 3: Iteration: 2000 / 2000 [100%] (Sampling) ## Chain 3: ## Chain 3: Elapsed Time: 0.222986 seconds (Warm-up) ## Chain 3: 0.094176 seconds (Sampling) ## Chain 3: 0.317162 seconds (Total) ## Chain 3: ## ## SAMPLING FOR MODEL &#39;d906ce8b7473e128d4f1de38161b730f&#39; NOW (CHAIN 4). ## Chain 4: ## Chain 4: Gradient evaluation took 1.7e-05 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.17 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4: ## Chain 4: ## Chain 4: Iteration: 1 / 2000 [ 0%] (Warmup) ## Chain 4: Iteration: 200 / 2000 [ 10%] (Warmup) ## Chain 4: Iteration: 400 / 2000 [ 20%] (Warmup) ## Chain 4: Iteration: 600 / 2000 [ 30%] (Warmup) ## Chain 4: Iteration: 800 / 2000 [ 40%] (Warmup) ## Chain 4: Iteration: 1000 / 2000 [ 50%] (Warmup) ## Chain 4: Iteration: 1001 / 2000 [ 50%] (Sampling) ## Chain 4: Iteration: 1200 / 2000 [ 60%] (Sampling) ## Chain 4: Iteration: 1400 / 2000 [ 70%] (Sampling) ## Chain 4: Iteration: 1600 / 2000 [ 80%] (Sampling) ## Chain 4: Iteration: 1800 / 2000 [ 90%] (Sampling) ## Chain 4: Iteration: 2000 / 2000 [100%] (Sampling) ## Chain 4: ## Chain 4: Elapsed Time: 0.212432 seconds (Warm-up) ## Chain 4: 0.091739 seconds (Sampling) ## Chain 4: 0.304171 seconds (Total) ## Chain 4: flies_stan &lt;- stanfit(flies_brm) flies_stan ## Inference for Stan model: d906ce8b7473e128d4f1de38161b730f. ## 4 chains, each with iter=2000; warmup=1000; thin=1; ## post-warmup draws per chain=1000, total post-warmup draws=4000. ## ## mean se_mean sd 2.5% 25% 50% ## b_Intercept 63.59 0.06 3.00 57.62 61.64 63.63 ## b_CompanionNumberPregnant1 1.21 0.08 4.22 -7.07 -1.68 1.16 ## b_CompanionNumberPregnant8 -0.22 0.08 4.27 -8.67 -3.08 -0.23 ## b_CompanionNumberVirgin1 -6.89 0.08 4.19 -14.97 -9.72 -7.00 ## b_CompanionNumberVirgin8 -24.83 0.08 4.23 -32.98 -27.52 -24.85 ## sigma 14.90 0.02 0.96 13.16 14.24 14.87 ## lp__ -519.59 0.04 1.77 -523.77 -520.54 -519.25 ## 75% 97.5% n_eff Rhat ## b_Intercept 65.57 69.59 2664 1 ## b_CompanionNumberPregnant1 3.98 9.56 2869 1 ## b_CompanionNumberPregnant8 2.66 7.87 2891 1 ## b_CompanionNumberVirgin1 -4.10 1.56 2998 1 ## b_CompanionNumberVirgin8 -22.06 -16.37 2955 1 ## sigma 15.50 16.93 3841 1 ## lp__ -518.29 -517.15 1802 1 ## ## Samples were drawn using NUTS(diag_e) at Thu Apr 11 17:30:09 2019. ## For each parameter, n_eff is a crude measure of effective sample size, ## and Rhat is the potential scale reduction factor on split chains (at ## convergence, Rhat=1). mcmc_combo(as.mcmc.list(flies_stan)) But what just happened? Why do we have 5 parameters starting with b_? Our first clue comes from looking at the data that get sent to Stan. standata(flies_brm) %&gt;% lapply(head) ## $N ## [1] 125 ## ## $Y ## [1] 35 37 49 46 63 39 ## ## $K ## [1] 5 ## ## $X ## Intercept CompanionNumberPregnant1 CompanionNumberPregnant8 ## 1 1 0 1 ## 2 1 0 1 ## 3 1 0 1 ## 4 1 0 1 ## 5 1 0 1 ## 6 1 0 1 ## CompanionNumberVirgin1 CompanionNumberVirgin8 ## 1 0 0 ## 2 0 0 ## 3 0 0 ## 4 0 0 ## 5 0 0 ## 6 0 0 ## ## $prior_only ## [1] 0 Our CompanionNumber variable has been turned into 4 new 0/1 variables. So our model is \\[\\begin{align*} \\mathrm{Longevity} &amp;= \\beta_0 \\cdot 1 + \\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 x_3 + \\beta_4 x_4 + \\mathrm{noise} \\\\ \\beta_0 \\cdot 1 + \\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 x_3 + \\beta_4 x_4 + {\\sf Norm}(0, \\sigma) \\end{align*}\\] where, for example, \\[\\begin{align*} x_1 &amp;= [\\![ \\mbox{CompanionNumber} = \\mbox{Pregnant1} ]\\!] \\\\ &amp;= \\begin{cases} 1 &amp; \\mbox{if CompanionNumber} = \\mbox{Pregnant1} \\\\ 0 &amp; \\mbox{if CampanionNumber} \\neq \\mbox{Pregnant1} \\end{cases} \\end{align*}\\] In other words the distribution of longevity is \\({\\sf Norm}(\\beta_0, \\sigma)\\) for the None0 group \\({\\sf Norm}(\\beta_0 + \\beta_1, \\sigma)\\) for the Pregnant1 group \\({\\sf Norm}(\\beta_0 + \\beta_2, \\sigma)\\) for the Pregnant2 group \\({\\sf Norm}(\\beta_0 + \\beta_3, \\sigma)\\) for the Virgin1 group \\({\\sf Norm}(\\beta_0 + \\beta_4, \\sigma)\\) for the Virgin2 group Here are the default priors. get_prior(Longevity ~ CompanionNumber, data = FruitflyReduced) prior class coef group resp dpar nlpar bound b b CompanionNumberPregnant1 b CompanionNumberPregnant8 b CompanionNumberVirgin1 b CompanionNumberVirgin8 student_t(3, 58, 18) Intercept student_t(3, 0, 18) sigma Flat improper priors for the b_ parameters. t-distribution with 3 degrees of freedom for the intercept (heavier tails than a normal distribution) “T” for sigma. (This is really a “half t”, since Stan knows the parameter must be positive.) For now, we’ll stick with these defaults, but it would be easy to use other things if we wanted. flies_post &lt;- posterior(flies_stan) names(flies_post) ## [1] &quot;b_Intercept&quot; &quot;b_CompanionNumberPregnant1&quot; ## [3] &quot;b_CompanionNumberPregnant8&quot; &quot;b_CompanionNumberVirgin1&quot; ## [5] &quot;b_CompanionNumberVirgin8&quot; &quot;sigma&quot; ## [7] &quot;lp__&quot; &quot;chain&quot; ## [9] &quot;iter&quot; 19.1.1 Comparing two groups Some comparisions are easy. Comparing any of the other groups to the None0 group is a matter of looking at the posterior distribution of one of our parameters. plot_post(flies_post$b_CompanionNumberPregnant1) ## $posterior ## ESS mean median mode ## var1 2985 1.208 1.162 1.206 ## ## $hdi ## prob lo hi ## 1 0.95 -7.082 9.551 hdi(flies_post$b_CompanionNumberPregnant1) par lo hi prob var1 -7.082 9.551 0.95 plot_post(flies_post$b_CompanionNumberVirgin1) ## $posterior ## ESS mean median mode ## var1 3040 -6.895 -7.003 -7.352 ## ## $hdi ## prob lo hi ## 1 0.95 -15.01 1.409 hdi(flies_post$b_CompanionNumberVirgin1) par lo hi prob var1 -15.01 1.409 0.95 "]
]
